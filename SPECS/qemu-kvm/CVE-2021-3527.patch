Backported from upstream commits by Gerd Hoffmann <kraxel@redhat.com>
https://lists.nongnu.org/archive/html/qemu-devel/2021-05/msg00564.html

Signed-off-by: Nicolas Ontiveros <niontive@microsoft.com>
--- a/hw/usb/dev-hid.c	2019-12-12 10:20:47.000000000 -0800
+++ b/hw/usb/dev-hid.c	2021-06-18 10:24:36.926202610 -0700
@@ -667,7 +667,7 @@
 {
     USBHIDState *us = USB_HID(dev);
     HIDState *hs = &us->hid;
-    uint8_t buf[p->iov.size];
+    g_autofree uint8_t *buf = g_malloc(p->iov.size);
     int len = 0;
 
     switch (p->pid) {

--- a/hw/usb/dev-wacom.c	2019-12-12 10:20:47.000000000 -0800
+++ b/hw/usb/dev-wacom.c	2021-06-18 10:25:31.758748961 -0700
@@ -306,7 +306,7 @@
 static void usb_wacom_handle_data(USBDevice *dev, USBPacket *p)
 {
     USBWacomState *s = (USBWacomState *) dev;
-    uint8_t buf[p->iov.size];
+    g_autofree uint8_t *buf = g_malloc(p->iov.size);
     int len = 0;
 
     switch (p->pid) {

--- a/hw/usb/redirect.c	2019-12-12 10:20:47.000000000 -0800
+++ b/hw/usb/redirect.c	2021-06-18 10:30:00.137462057 -0700
@@ -607,7 +607,7 @@
                 .endpoint = ep,
                 .length = p->iov.size
             };
-            uint8_t buf[p->iov.size];
+            g_autofree uint8_t *buf = g_malloc(p->iov.size);
             /* No id, we look at the ep when receiving a status back */
             usb_packet_copy(p, buf, p->iov.size);
             usbredirparser_send_iso_packet(dev->parser, 0, &iso_packet,
@@ -805,7 +805,7 @@
         usbredirparser_send_bulk_packet(dev->parser, p->id,
                                         &bulk_packet, NULL, 0);
     } else {
-        uint8_t buf[size];
+        g_autofree uint8_t *buf = g_malloc(size);
         usb_packet_copy(p, buf, size);
         usbredir_log_data(dev, "bulk data out:", buf, size);
         usbredirparser_send_bulk_packet(dev->parser, p->id,
@@ -910,7 +910,7 @@
                                                USBPacket *p, uint8_t ep)
 {
     struct usb_redir_interrupt_packet_header interrupt_packet;
-    uint8_t buf[p->iov.size];
+    g_autofree uint8_t *buf = g_malloc(p->iov.size);
 
     DPRINTF("interrupt-out ep %02X len %zd id %"PRIu64"\n", ep,
             p->iov.size, p->id);

--- a/hw/usb/dev-mtp.c	2019-12-12 10:20:47.000000000 -0800
+++ b/hw/usb/dev-mtp.c	2021-06-18 10:32:03.890772495 -0700
@@ -906,7 +906,8 @@
                                            MTPObject *o)
 {
     MTPData *d = usb_mtp_data_alloc(c);
-    uint32_t i = 0, handles[o->nchildren];
+    uint32_t i = 0;
+    g_autofree uint32_t *handles = g_new(uint32_t, o->nchildren);
     MTPObject *iter;
 
     trace_usb_mtp_op_get_object_handles(s->dev.addr, o->handle, o->path);

--- a/hw/usb/hcd-xhci.c	2019-12-12 10:20:47.000000000 -0800
+++ b/hw/usb/hcd-xhci.c	2021-06-18 10:35:58.137218301 -0700
@@ -1616,6 +1616,11 @@
     usb_packet_setup(&xfer->packet, dir, ep, xfer->streamid,
                      xfer->trbs[0].addr, false, xfer->int_req);
     usb_packet_map(&xfer->packet, &xfer->sgl);
+    if (xfer->packet.iov.size > ep->max_packet_size) {
+        usb_packet_unmap(&xfer->packet, &xfer->sgl);
+        qemu_sglist_destroy(&xfer->sgl);
+        return -1;
+    }
     DPRINTF("xhci: setup packet pid 0x%x addr %d ep %d\n",
             xfer->packet.pid, ep->dev->addr, ep->nr);
     return 0;

--- a/hw/usb/combined-packet.c	2019-12-12 10:20:47.000000000 -0800
+++ b/hw/usb/combined-packet.c	2021-06-18 10:37:22.794093862 -0700
@@ -171,7 +171,9 @@
         if ((p->iov.size % ep->max_packet_size) != 0 || !p->short_not_ok ||
                 next == NULL ||
                 /* Work around for Linux usbfs bulk splitting + migration */
-                (totalsize == (16 * KiB - 36) && p->int_req)) {
+                (totalsize == (16 * KiB - 36) && p->int_req) ||
+                /* Next package may grow combined package over 1MiB */
+                totalsize > 1 * MiB - ep->max_packet_size) {
             usb_device_handle_data(ep->dev, first);
             assert(first->status == USB_RET_ASYNC);
             if (first->combined) {
