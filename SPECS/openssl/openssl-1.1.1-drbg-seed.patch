diff --git a/crypto/fips/fips_drbg_lib.c b/crypto/fips/fips_drbg_lib.c
index 1c6ff1b..4d3a65c 100644
--- a/crypto/fips/fips_drbg_lib.c
+++ b/crypto/fips/fips_drbg_lib.c
@@ -58,6 +58,7 @@
 #include <openssl/fips_rand.h>
 #include "fips_locl.h"
 #include "fips_rand_lcl.h"
+#include "../../include/crypto/rand.h"
 
 /* Support framework for SP800-90 DRBGs */
 
@@ -139,6 +140,110 @@ void FIPS_drbg_free(DRBG_CTX *dctx)
     }
 }
 
+static size_t fips_concatenate_lrng(DRBG_CTX *dctx,
+                                    unsigned char **pout,
+                                    size_t str_len,
+                                    size_t max_str_len)
+{
+    unsigned char *tmp_str = NULL;
+    size_t idx = 0, total_bytes = 0, bytes_needed = 0;
+    ssize_t bytes = 0;
+    int rng_attempts = 3;
+
+    bytes_needed = dctx->strength / 8;
+
+    total_bytes = bytes_needed + str_len;
+
+    if (total_bytes < bytes_needed) {
+        FIPSerr(FIPS_F_FIPS_DRBG_LRNG, ERR_R_PASSED_INVALID_ARGUMENT);
+        goto err;
+    }
+    
+    if (total_bytes > max_str_len) {
+        FIPSerr(FIPS_F_FIPS_DRBG_LRNG, ERR_R_PASSED_INVALID_ARGUMENT);
+        goto err;
+    }
+
+    tmp_str = OPENSSL_zalloc(total_bytes);
+    if (tmp_str == NULL) {
+        FIPSerr(FIPS_F_FIPS_DRBG_LRNG, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    if (*pout != NULL) {
+        memcpy(tmp_str, *pout, str_len);
+    }
+
+    idx = str_len;
+
+    while (bytes_needed != 0 && rng_attempts-- > 0) {
+        bytes = syscall_random(tmp_str + idx, bytes_needed, 0);
+        if (bytes > 0) {
+            idx += bytes;
+            bytes_needed -= bytes;
+            rng_attempts = 3; /* reset counter after successful attempt */
+        } else if (bytes < 0 && errno != EINTR) {
+            break;
+        }
+    }
+
+    if (bytes_needed == 0) {
+        *pout = tmp_str;
+        return total_bytes;
+    }
+
+    FIPSerr(FIPS_F_FIPS_DRBG_LRNG, FIPS_R_ERROR_RETRIEVING_RAND);
+
+err:
+    if (tmp_str != NULL)
+        OPENSSL_clear_free(tmp_str, total_bytes);
+    return 0;
+}
+
+static size_t fips_get_pers(DRBG_CTX *dctx,
+                            unsigned char **pout, size_t pers_len)
+{
+    if (dctx->get_pers != NULL) {
+        return dctx->get_pers(dctx, pout, pers_len);
+    }
+
+    return fips_concatenate_lrng(dctx, pout, pers_len, dctx->max_pers);
+}
+
+static size_t fips_get_adin(DRBG_CTX *dctx,
+                     unsigned char **pout, size_t adin_len)
+{
+    if (dctx->get_adin != NULL) {
+        return dctx->get_adin(dctx, pout, adin_len);
+    }
+
+    return fips_concatenate_lrng(dctx, pout, adin_len, dctx->max_adin);
+}
+
+static void fips_cleanup_pers(DRBG_CTX *dctx,
+                              unsigned char *out, size_t outlen)
+{
+    if (dctx->cleanup_pers != NULL) {
+        return dctx->cleanup_pers(dctx, out, outlen);
+    }
+
+    if (out != NULL) {
+        OPENSSL_clear_free(out, outlen);
+    }
+}
+
+static void fips_cleanup_adin(DRBG_CTX *dctx,
+                              unsigned char *out, size_t outlen)
+{
+    if (dctx->cleanup_adin != NULL) {
+        return dctx->cleanup_adin(dctx, out, outlen);
+    }
+
+    if (out != NULL) {
+        OPENSSL_clear_free(out, outlen);
+    }
+}
+
 static size_t fips_get_entropy(DRBG_CTX *dctx, unsigned char **pout,
                                int entropy, size_t min_len, size_t max_len)
 {
@@ -185,6 +290,7 @@ int FIPS_drbg_instantiate(DRBG_CTX *dctx,
 {
     size_t entlen = 0, noncelen = 0;
     unsigned char *nonce = NULL, *entropy = NULL;
+    const unsigned char *tmp_pers = NULL;
 
 #if 0
     /* Put here so error script picks them up */
@@ -198,7 +304,7 @@ int FIPS_drbg_instantiate(DRBG_CTX *dctx,
     FIPSerr(FIPS_F_FIPS_DRBG_INSTANTIATE, FIPS_R_DRBG_NOT_INITIALISED);
 #endif
 
-    int r = 0;
+    int r = 0, pers_alloc = 0;
 
     if (perslen > dctx->max_pers) {
         r = FIPS_R_PERSONALISATION_STRING_TOO_LONG;
@@ -240,6 +346,18 @@ int FIPS_drbg_instantiate(DRBG_CTX *dctx,
 
     }
 
+    tmp_pers = pers;
+
+    perslen = fips_get_pers(dctx, &pers, perslen);
+    if (perslen == 0) {
+        r = FIPS_R_ERROR_RETRIEVING_PERS;
+        goto end;
+    }
+
+    if (tmp_pers != pers) {
+        pers_alloc = 1;
+    }
+
     if (!dctx->instantiate(dctx,
                            entropy, entlen, nonce, noncelen, pers, perslen)) {
         r = FIPS_R_ERROR_INSTANTIATING_DRBG;
@@ -251,6 +369,8 @@ int FIPS_drbg_instantiate(DRBG_CTX *dctx,
         dctx->reseed_counter = 1;
 
  end:
+    if (pers != NULL && pers_alloc)
+        fips_cleanup_pers(dctx, pers, perslen);
 
     if (entropy && dctx->cleanup_entropy)
         fips_cleanup_entropy(dctx, entropy, entlen);
@@ -272,8 +392,9 @@ static int drbg_reseed(DRBG_CTX *dctx,
                        const unsigned char *adin, size_t adinlen, int hcheck)
 {
     unsigned char *entropy = NULL;
+    const unsigned char *tmp_adin = NULL;
     size_t entlen = 0;
-    int r = 0;
+    int r = 0, adin_alloc = 0;
 
 #if 0
     FIPSerr(FIPS_F_DRBG_RESEED, FIPS_R_NOT_INSTANTIATED);
@@ -314,6 +435,18 @@ static int drbg_reseed(DRBG_CTX *dctx,
         goto end;
     }
 
+    tmp_adin = adin;
+
+    adinlen = fips_get_adin(dctx, &adin, adinlen);
+    if (adinlen == 0) {
+        r = FIPS_R_ERROR_RETRIEVING_ADIN;
+        goto end;
+    }
+
+    if (tmp_adin != adin) {
+        adin_alloc = 1;
+    }
+
     if (!dctx->reseed(dctx, entropy, entlen, adin, adinlen))
         goto end;
 
@@ -322,6 +455,9 @@ static int drbg_reseed(DRBG_CTX *dctx,
         dctx->reseed_counter = 1;
  end:
 
+    if (adin != NULL && adin_alloc)
+        fips_cleanup_adin(dctx, adin, adinlen);
+
     if (entropy && dctx->cleanup_entropy)
         fips_cleanup_entropy(dctx, entropy, entlen);
 
@@ -462,7 +598,7 @@ int FIPS_drbg_set_callbacks(DRBG_CTX *dctx,
 {
     if (dctx->status != DRBG_STATUS_UNINITIALISED)
         return 0;
-    dctx->entropy_blocklen = entropy_blocklen;
+    dctx->entropy_blocklen = entropy_blocklen; 
     dctx->get_entropy = get_entropy;
     dctx->cleanup_entropy = cleanup_entropy;
     dctx->get_nonce = get_nonce;
@@ -470,12 +606,51 @@ int FIPS_drbg_set_callbacks(DRBG_CTX *dctx,
     return 1;
 }
 
-int FIPS_drbg_set_rand_callbacks(DRBG_CTX *dctx,
-                                 size_t (*get_adin) (DRBG_CTX *ctx,
-                                                     unsigned char **pout),
-                                 void (*cleanup_adin) (DRBG_CTX *ctx,
+int FIPS_drbg_set_all_callbacks(DRBG_CTX *dctx,
+                                size_t (*get_pers) (DRBG_CTX *ctx,
+                                                   unsigned char **pout,
+                                                   size_t pers_len),
+                                void (*cleanup_pers) (DRBG_CTX *ctx,
+                                                      unsigned char *out,
+                                                      size_t olen),
+                                size_t (*get_adin) (DRBG_CTX *ctx,
+                                                    unsigned char **pout,
+                                                    size_t adin_len),
+                                void (*cleanup_adin) (DRBG_CTX *ctx,
+                                                      unsigned char *out,
+                                                      size_t olen),
+                                size_t (*get_entropy) (DRBG_CTX *ctx,
+                                                       unsigned char **pout,
+                                                       int entropy,
+                                                       size_t min_len,
+                                                       size_t max_len),
+                                void (*cleanup_entropy) (DRBG_CTX *ctx,
+                                                         unsigned char *out,
+                                                         size_t olen),
+                                size_t entropy_blocklen,
+                                size_t (*get_nonce) (DRBG_CTX *ctx,
+                                                     unsigned char **pout,
+                                                     int entropy, size_t min_len,
+                                                     size_t max_len),
+                                void (*cleanup_nonce) (DRBG_CTX *ctx,
                                                        unsigned char *out,
-                                                       size_t olen),
+                                                       size_t olen))
+{
+    if (dctx->status != DRBG_STATUS_UNINITIALISED)
+        return 0;
+    dctx->get_pers = get_pers;
+    dctx->cleanup_pers = cleanup_pers;
+    dctx->get_adin = get_adin;
+    dctx->cleanup_adin = cleanup_adin;
+    dctx->entropy_blocklen = entropy_blocklen; 
+    dctx->get_entropy = get_entropy;
+    dctx->cleanup_entropy = cleanup_entropy;
+    dctx->get_nonce = get_nonce;
+    dctx->cleanup_nonce = cleanup_nonce;
+    return 1;
+}
+
+int FIPS_drbg_set_rand_callbacks(DRBG_CTX *dctx,
                                  int (*rand_seed_cb) (DRBG_CTX *ctx,
                                                       const void *buf,
                                                       int num),
@@ -485,8 +660,6 @@ int FIPS_drbg_set_rand_callbacks(DRBG_CTX *dctx,
 {
     if (dctx->status != DRBG_STATUS_UNINITIALISED)
         return 0;
-    dctx->get_adin = get_adin;
-    dctx->cleanup_adin = cleanup_adin;
     dctx->rand_seed_cb = rand_seed_cb;
     dctx->rand_add_cb = rand_add_cb;
     return 1;
diff --git a/crypto/fips/fips_drbg_rand.c b/crypto/fips/fips_drbg_rand.c
index 492bb7d..46626e8 100644
--- a/crypto/fips/fips_drbg_rand.c
+++ b/crypto/fips/fips_drbg_rand.c
@@ -98,7 +98,7 @@ static int fips_drbg_bytes(unsigned char *out, int count)
         else
             rcnt = count;
         if (dctx->get_adin) {
-            adinlen = dctx->get_adin(dctx, &adin);
+            adinlen = dctx->get_adin(dctx, &adin, dctx->max_adin);
             if (adinlen && !adin) {
                 FIPSerr(FIPS_F_FIPS_DRBG_BYTES,
                         FIPS_R_ERROR_RETRIEVING_ADDITIONAL_INPUT);
diff --git a/crypto/fips/fips_drbg_selftest.c b/crypto/fips/fips_drbg_selftest.c
index d6d0566..ca91345 100644
--- a/crypto/fips/fips_drbg_selftest.c
+++ b/crypto/fips/fips_drbg_selftest.c
@@ -164,6 +164,16 @@ typedef struct {
     int noncecnt;
 } TEST_ENT;
 
+static size_t test_pers(DRBG_CTX *dctx, unsigned char **pout, size_t pers_len)
+{
+    return pers_len;
+}
+
+static size_t test_adin(DRBG_CTX *dctx, unsigned char **pout, size_t adin_len)
+{
+    return adin_len;
+}
+
 static size_t test_entropy(DRBG_CTX *dctx, unsigned char **pout,
                            int entropy, size_t min_len, size_t max_len)
 {
@@ -198,7 +208,8 @@ static int fips_drbg_single_kat(DRBG_CTX *dctx, DRBG_SELFTEST_DATA * td,
 
     if (!FIPS_drbg_init(dctx, td->nid, td->flags))
         return 0;
-    if (!FIPS_drbg_set_callbacks(dctx, test_entropy, 0, 0, test_nonce, 0))
+    if (!FIPS_drbg_set_all_callbacks(dctx, test_pers, 0, test_adin, 0,
+                                     test_entropy, 0, 0, test_nonce, 0))
         return 0;
 
     FIPS_drbg_set_app_data(dctx, &t);
@@ -261,7 +272,8 @@ static int fips_drbg_single_kat(DRBG_CTX *dctx, DRBG_SELFTEST_DATA * td,
      */
     if (!FIPS_drbg_init(dctx, td->nid, td->flags))
         return 0;
-    if (!FIPS_drbg_set_callbacks(dctx, test_entropy, 0, 0, test_nonce, 0))
+    if (!FIPS_drbg_set_all_callbacks(dctx, test_pers, 0, test_adin, 0,
+                                     test_entropy, 0, 0, test_nonce, 0))
         return 0;
 
     FIPS_drbg_set_app_data(dctx, &t);
@@ -336,7 +348,8 @@ static int do_drbg_init(DRBG_CTX *dctx, DRBG_SELFTEST_DATA * td, TEST_ENT * t)
     if (!FIPS_drbg_init(dctx, td->nid, td->flags))
         return 0;
 
-    if (!FIPS_drbg_set_callbacks(dctx, test_entropy, 0, 0, test_nonce, 0))
+    if (!FIPS_drbg_set_all_callbacks(dctx, test_pers, 0, test_adin, 0,
+                                     test_entropy, 0, 0, test_nonce, 0))
         return 0;
 
     FIPS_drbg_set_app_data(dctx, t);
diff --git a/crypto/fips/fips_err.h b/crypto/fips/fips_err.h
index 9a9c9a1..c09cc09 100644
--- a/crypto/fips/fips_err.h
+++ b/crypto/fips/fips_err.h
@@ -91,6 +91,7 @@ static ERR_STRING_DATA FIPS_str_functs[] = {
     {ERR_FUNC(FIPS_F_FIPS_DRBG_NEW), "FIPS_drbg_new"},
     {ERR_FUNC(FIPS_F_FIPS_DRBG_RESEED), "FIPS_drbg_reseed"},
     {ERR_FUNC(FIPS_F_FIPS_DRBG_SINGLE_KAT), "FIPS_DRBG_SINGLE_KAT"},
+    {ERR_FUNC(FIPS_F_FIPS_DRBG_LRNG), "fips_concatenate_lrng"},
     {ERR_FUNC(FIPS_F_FIPS_GET_ENTROPY), "fips_get_entropy"},
     {ERR_FUNC(FIPS_F_FIPS_MODULE_MODE_SET), "FIPS_module_mode_set"},
     {ERR_FUNC(FIPS_F_FIPS_PKEY_SIGNATURE_TEST), "fips_pkey_signature_test"},
@@ -187,6 +188,9 @@ static ERR_STRING_DATA FIPS_str_reasons[] = {
      "uninstantiate zeroise error"},
     {ERR_REASON(FIPS_R_UNSUPPORTED_DRBG_TYPE), "unsupported drbg type"},
     {ERR_REASON(FIPS_R_UNSUPPORTED_PLATFORM), "unsupported platform"},
+    {ERR_REASON(FIPS_R_ERROR_RETRIEVING_PERS), "error retrieving personalization string"},
+    {ERR_REASON(FIPS_R_ERROR_RETRIEVING_ADIN), "error retrieving additional input string"},
+    {ERR_REASON(FIPS_R_ERROR_RETRIEVING_RAND), "error retrieving random bytes from LRNG"},
     {0, NULL}
 };
 
diff --git a/crypto/fips/fips_rand_lcl.h b/crypto/fips/fips_rand_lcl.h
index cab1657..3f04344 100644
--- a/crypto/fips/fips_rand_lcl.h
+++ b/crypto/fips/fips_rand_lcl.h
@@ -166,6 +166,18 @@ struct drbg_ctx_st {
     /* uninstantiate */
     int (*uninstantiate) (DRBG_CTX *ctx);
 
+    /* personal string gathering function */
+    size_t (*get_pers) (DRBG_CTX *ctx, unsigned char **pout, size_t pers_len);
+
+    /* Indicates we have finished with personal string buffer */
+    void (*cleanup_pers) (DRBG_CTX *ctx, unsigned char *out, size_t olen);
+    
+    /* additional input gathering function */
+    size_t (*get_adin) (DRBG_CTX *ctx, unsigned char **pout, size_t adin_len);
+
+    /* Indicates we have finished with additional buffer */
+    void (*cleanup_adin) (DRBG_CTX *ctx, unsigned char *out, size_t olen);
+
     /* Entropy source block length */
     size_t entropy_blocklen;
 
@@ -181,10 +193,6 @@ struct drbg_ctx_st {
     /* Indicates we have finished with nonce buffer */
     void (*cleanup_nonce) (DRBG_CTX *ctx, unsigned char *out, size_t olen);
 
-    /* Callbacks used when called through RAND interface */
-    /* Get any additional input for generate */
-    size_t (*get_adin) (DRBG_CTX *ctx, unsigned char **pout);
-    void (*cleanup_adin) (DRBG_CTX *ctx, unsigned char *out, size_t olen);
     /* Callback for RAND_seed(), RAND_add() */
     int (*rand_seed_cb) (DRBG_CTX *ctx, const void *buf, int num);
     int (*rand_add_cb) (DRBG_CTX *ctx,
diff --git a/crypto/rand/drbg_lib.c b/crypto/rand/drbg_lib.c
index 5d7a1d7..21928e3 100644
--- a/crypto/rand/drbg_lib.c
+++ b/crypto/rand/drbg_lib.c
@@ -202,6 +202,12 @@ static RAND_DRBG *rand_drbg_new(int secure,
 
     if (parent == NULL) {
 #ifdef OPENSSL_FIPS
+        if (FIPS_mode()) {
+            drbg->get_pers = rand_drbg_get_pers;
+            drbg->get_adin = rand_drbg_get_adin;
+            drbg->cleanup_pers = rand_drbg_cleanup_pers;
+            drbg->cleanup_adin = rand_drbg_cleanup_adin;
+        }
         drbg->get_entropy = rand_crngt_get_entropy;
         drbg->cleanup_entropy = rand_crngt_cleanup_entropy;
 #else
@@ -298,6 +304,10 @@ int RAND_DRBG_instantiate(RAND_DRBG *drbg,
     size_t min_entropy = drbg->strength;
     size_t min_entropylen = drbg->min_entropylen;
     size_t max_entropylen = drbg->max_entropylen;
+#ifdef OPENSSL_FIPS
+    int pers_alloc = 0;
+    const unsigned char *tmp_pers = NULL;
+#endif
 
     if (perslen > drbg->max_perslen) {
         RANDerr(RAND_F_RAND_DRBG_INSTANTIATE,
@@ -350,6 +360,26 @@ int RAND_DRBG_instantiate(RAND_DRBG *drbg,
         }
     }
 
+#ifdef OPENSSL_FIPS
+    if (FIPS_mode()) {
+        if (drbg->get_pers != NULL) {
+            tmp_pers = pers;
+            perslen = drbg->get_pers(drbg, &pers, perslen);
+            if (perslen == 0) {
+                RANDerr(RAND_F_RAND_DRBG_INSTANTIATE, RAND_R_ERROR_RETRIEVING_PERS);
+                goto end;
+            }
+            if (tmp_pers != pers) {
+                pers_alloc = 1;
+            }
+        } else {
+            // FIPS mode requires LRNG concatenation of pers
+            RANDerr(RAND_F_RAND_DRBG_INSTANTIATE, RAND_R_ERROR_NO_LRNG_CONCAT);
+            goto end;
+        }
+    }
+#endif
+
     if (!drbg->meth->instantiate(drbg, entropy, entropylen,
                          nonce, noncelen, pers, perslen)) {
         RANDerr(RAND_F_RAND_DRBG_INSTANTIATE, RAND_R_ERROR_INSTANTIATING_DRBG);
@@ -368,6 +398,12 @@ int RAND_DRBG_instantiate(RAND_DRBG *drbg,
     }
 
  end:
+ #ifdef OPENSSL_FIPS
+    if (FIPS_mode()) {
+        if (pers != NULL && drbg->cleanup_pers != NULL && pers_alloc)
+            drbg->cleanup_pers(drbg, pers, perslen);
+    }
+ #endif
     if (entropy != NULL && drbg->cleanup_entropy != NULL)
         drbg->cleanup_entropy(drbg, entropy, entropylen);
     if (nonce != NULL && drbg->cleanup_nonce != NULL)
@@ -414,6 +450,10 @@ int RAND_DRBG_reseed(RAND_DRBG *drbg,
 {
     unsigned char *entropy = NULL;
     size_t entropylen = 0;
+#ifdef OPENSSL_FIPS
+    int adin_alloc = 0;
+    const unsigned char *tmp_adin = NULL;
+#endif
 
     if (drbg->state == DRBG_ERROR) {
         RANDerr(RAND_F_RAND_DRBG_RESEED, RAND_R_IN_ERROR_STATE);
@@ -443,6 +483,26 @@ int RAND_DRBG_reseed(RAND_DRBG *drbg,
         goto end;
     }
 
+#ifdef OPENSSL_FIPS
+    if (FIPS_mode()) {
+        if (drbg->get_adin != NULL) {
+            tmp_adin = adin;
+            adinlen = drbg->get_adin(drbg, &adin, adinlen);
+            if (adinlen == 0 || adin == NULL) {
+                RANDerr(RAND_F_RAND_DRBG_RESEED, RAND_R_ERROR_RETRIEVING_ADDITIONAL_INPUT);
+                goto end;
+            }
+            if (tmp_adin != adin) {
+                adin_alloc = 1;
+            }
+        } else {
+            // FIPS mode requires LRNG concatenation of adin
+            RANDerr(RAND_F_RAND_DRBG_RESEED, RAND_R_ERROR_NO_LRNG_CONCAT);
+            goto end;
+        }
+    }
+#endif
+
     if (!drbg->meth->reseed(drbg, entropy, entropylen, adin, adinlen))
         goto end;
 
@@ -458,6 +518,12 @@ int RAND_DRBG_reseed(RAND_DRBG *drbg,
     }
 
  end:
+#ifdef OPENSSL_FIPS
+    if (FIPS_mode()) {
+        if (adin != NULL && drbg->cleanup_adin != NULL && adin_alloc)
+            drbg->cleanup_adin(drbg, adin, adinlen);
+    }
+#endif
     if (entropy != NULL && drbg->cleanup_entropy != NULL)
         drbg->cleanup_entropy(drbg, entropy, entropylen);
     if (drbg->state == DRBG_READY)
@@ -693,6 +759,40 @@ int RAND_DRBG_bytes(RAND_DRBG *drbg, unsigned char *out, size_t outlen)
     return ret;
 }
 
+#ifdef OPENSSL_FIPS
+/*
+* Set the RAND_DRBG callbacks for obtaining entropy, nonce, 
+* personalization string and additional input params
+*
+* Setting the callbacks is allowed only if the drbg has not been
+* initialized yet. Otherwise, the operation will fail.
+*
+* Returns 1 on success, 0 on failure.
+*/
+int RAND_DRBG_set_fips_callbacks(RAND_DRBG *drbg,
+                                 RAND_DRBG_get_pers_fn get_pers,
+                                 RAND_DRBG_cleanup_pers_fn cleanup_pers,
+                                 RAND_DRBG_get_adin_fn get_adin,
+                                 RAND_DRBG_cleanup_adin_fn cleanup_adin,
+                                 RAND_DRBG_get_entropy_fn get_entropy,
+                                 RAND_DRBG_cleanup_entropy_fn cleanup_entropy,
+                                 RAND_DRBG_get_nonce_fn get_nonce,
+                                 RAND_DRBG_cleanup_nonce_fn cleanup_nonce)
+{
+    if (drbg->state != DRBG_UNINITIALISED)
+        return 0;
+    drbg->get_pers = get_pers;
+    drbg->cleanup_pers = cleanup_pers;
+    drbg->get_adin = get_adin;
+    drbg->cleanup_adin = cleanup_adin;
+    drbg->get_entropy = get_entropy;
+    drbg->cleanup_entropy = cleanup_entropy;
+    drbg->get_nonce = get_nonce;
+    drbg->cleanup_nonce = cleanup_nonce;
+    return 1;
+}
+#endif
+
 /*
  * Set the RAND_DRBG callbacks for obtaining entropy and nonce.
  *
diff --git a/crypto/rand/drbg_selftest.c b/crypto/rand/drbg_selftest.c
index 023242c..b6f9404 100644
--- a/crypto/rand/drbg_selftest.c
+++ b/crypto/rand/drbg_selftest.c
@@ -231,6 +231,18 @@ static const struct drbg_kat *drbg_test[] = { &kat1308, &kat1465, &kat3146 };
 
 static const size_t drbg_test_nelem = OSSL_NELEM(drbg_test);
 
+#ifdef OPENSSL_FIPS
+static size_t kat_pers(RAND_DRBG *drbg, unsigned char **pout, size_t pers_len)
+{
+    return pers_len;
+}
+
+static size_t kat_adin(RAND_DRBG *drbg, unsigned char **pout, size_t adin_len)
+{
+    return adin_len;
+}
+#endif
+
 static size_t kat_entropy(RAND_DRBG *drbg, unsigned char **pout,
                           int entropy, size_t min_len, size_t max_len,
                           int prediction_resistance)
@@ -276,9 +288,14 @@ static int single_kat_no_reseed(const struct drbg_kat *td)
 
     if ((drbg = RAND_DRBG_new(td->nid, flags, NULL)) == NULL)
         return 0;
-
+#ifndef OPENSSL_FIPS
     if (!RAND_DRBG_set_callbacks(drbg, kat_entropy, NULL,
                                  kat_nonce, NULL)) {
+#else
+    if (!RAND_DRBG_set_fips_callbacks(drbg, kat_pers, NULL,
+                                      kat_adin, NULL, kat_entropy,
+                                      NULL, kat_nonce, NULL)) {
+#endif
         failures++;
         goto err;
     }
@@ -336,9 +353,14 @@ static int single_kat_pr_false(const struct drbg_kat *td)
 
     if ((drbg = RAND_DRBG_new(td->nid, flags, NULL)) == NULL)
         return 0;
-
+#ifndef OPENSSL_FIPS
     if (!RAND_DRBG_set_callbacks(drbg, kat_entropy, NULL,
                                  kat_nonce, NULL)) {
+#else
+    if (!RAND_DRBG_set_fips_callbacks(drbg, kat_pers, NULL,
+                                      kat_adin, NULL, kat_entropy,
+                                      NULL, kat_nonce, NULL)) {
+#endif
         failures++;
         goto err;
     }
@@ -402,8 +424,14 @@ static int single_kat_pr_true(const struct drbg_kat *td)
     if ((drbg = RAND_DRBG_new(td->nid, flags, NULL)) == NULL)
         return 0;
 
+#ifndef OPENSSL_FIPS
     if (!RAND_DRBG_set_callbacks(drbg, kat_entropy, NULL,
                                  kat_nonce, NULL)) {
+#else
+    if (!RAND_DRBG_set_fips_callbacks(drbg, kat_pers, NULL,
+                                      kat_adin, NULL, kat_entropy,
+                                      NULL, kat_nonce, NULL)) {
+#endif
         failures++;
         goto err;
     }
@@ -493,8 +521,14 @@ static int test_drbg_sanity(const struct drbg_kat *td)
     if ((drbg = RAND_DRBG_new(td->nid, flags, NULL)) == NULL)
         return 0;
 
+#ifndef OPENSSL_FIPS
     if (!RAND_DRBG_set_callbacks(drbg, kat_entropy, NULL,
                                  kat_nonce, NULL)) {
+#else
+    if (!RAND_DRBG_set_fips_callbacks(drbg, kat_pers, NULL,
+                                      kat_adin, NULL, kat_entropy,
+                                      NULL, kat_nonce, NULL)) {
+#endif
         failures++;
         goto err;
     }
diff --git a/crypto/rand/rand_err.c b/crypto/rand/rand_err.c
index a3ae5f5..2c9962d 100644
--- a/crypto/rand/rand_err.c
+++ b/crypto/rand/rand_err.c
@@ -25,6 +25,12 @@ static const ERR_STRING_DATA RAND_str_functs[] = {
      "rand_drbg_enable_locking"},
     {ERR_PACK(ERR_LIB_RAND, RAND_F_RAND_DRBG_GENERATE, 0),
      "RAND_DRBG_generate"},
+#ifdef OPENSSL_FIPS
+    {ERR_PACK(ERR_LIB_RAND, RAND_F_RAND_DRBG_GET_PERS, 0),
+     "rand_drbg_get_pers"},
+    {ERR_PACK(ERR_LIB_RAND, RAND_F_RAND_DRBG_GET_ADIN, 0),
+     "rand_drbg_get_adin"},
+#endif
     {ERR_PACK(ERR_LIB_RAND, RAND_F_RAND_DRBG_GET_ENTROPY, 0),
      "rand_drbg_get_entropy"},
     {ERR_PACK(ERR_LIB_RAND, RAND_F_RAND_DRBG_GET_NONCE, 0),
diff --git a/crypto/rand/rand_lib.c b/crypto/rand/rand_lib.c
index d8d3498..f6f2bb4 100644
--- a/crypto/rand/rand_lib.c
+++ b/crypto/rand/rand_lib.c
@@ -117,6 +117,116 @@ size_t rand_acquire_entropy_from_cpu(RAND_POOL *pool)
 }
 #endif
 
+#ifdef OPENSSL_FIPS
+
+static size_t fips_concatenate_lrng(RAND_DRBG *drbg,
+                                    unsigned char **pout,
+                                    size_t str_len,
+                                    size_t max_str_len)
+{
+    unsigned char *tmp_str = NULL;
+    size_t idx = 0, total_bytes = 0, bytes_needed = 0;
+    ssize_t bytes = 0;
+    int rng_attempts = 3;
+
+    bytes_needed = drbg->strength / 8;
+
+    total_bytes = bytes_needed + str_len;
+
+    if (total_bytes < bytes_needed) {
+        RANDerr(RAND_F_RAND_DRBG_LRNG, ERR_R_PASSED_INVALID_ARGUMENT);
+        goto err;
+    }
+
+    if (total_bytes > max_str_len) {
+        RANDerr(RAND_F_RAND_DRBG_LRNG, ERR_R_PASSED_INVALID_ARGUMENT);
+        goto err;
+    }
+
+    tmp_str = OPENSSL_zalloc(total_bytes);
+    if (tmp_str == NULL) {
+        RANDerr(RAND_F_RAND_DRBG_LRNG, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    if (*pout != NULL) {
+        memcpy(tmp_str, *pout, str_len);
+    }
+
+    idx = str_len;
+
+    while (bytes_needed != 0 && rng_attempts-- > 0) {
+        bytes = syscall_random(tmp_str + idx, bytes_needed, 0);
+        if (bytes > 0) {
+            idx += bytes;
+            bytes_needed -= bytes;
+            rng_attempts = 3; /* reset counter after successful attempt */
+        } else if (bytes < 0 && errno != EINTR) {
+            break;
+        }
+    }
+
+    if (bytes_needed == 0) {
+        *pout = tmp_str;
+        return total_bytes;
+    }
+
+    RANDerr(RAND_F_RAND_DRBG_LRNG, RAND_R_ERROR_RETRIEVING_RAND);
+
+err:
+    if (tmp_str != NULL)
+        OPENSSL_clear_free(tmp_str, total_bytes);
+    return 0;
+}
+
+/*
+ * Implements the get_pers() callback (see RAND_DRBG_set_fips_callbacks())
+ * 
+ * Concatenate the personalization string with random bits from Linux RNG
+ */
+
+size_t rand_drbg_get_pers(RAND_DRBG *drbg,
+                          unsigned char **pout, size_t pers_len)
+{
+    return fips_concatenate_lrng(drbg, pout, pers_len, drbg->max_perslen);
+}
+
+/*
+ * Implements the get_adin() callback (see RAND_DRBG_set_fips_callbacks())
+ *
+ * Concatenate the additional input string with random bits from Linux RNG
+ */
+size_t rand_drbg_get_adin(RAND_DRBG *drbg,
+                          unsigned char **pout, size_t adin_len)
+{
+    return fips_concatenate_lrng(drbg, pout, adin_len, drbg->max_adinlen);
+}
+
+/*
+ * Implements the cleanup_pers() callback (see RAND_DRBG_set_fips_callbacks())
+ *
+ */
+void rand_drbg_cleanup_pers(RAND_DRBG *drbg,
+                            unsigned char *out, size_t outlen)
+{
+    if (out != NULL) {
+        OPENSSL_clear_free(out, outlen);
+    }
+}
+
+/*
+ * Implements the cleanup_adin() callback (see RAND_DRBG_set_fips_callbacks())
+ *
+ */
+void rand_drbg_cleanup_adin(RAND_DRBG *drbg,
+                            unsigned char *out, size_t outlen)
+{
+    if (out != NULL) {
+        OPENSSL_clear_free(out, outlen);
+    }
+}
+
+#endif
 
 /*
  * Implements the get_entropy() callback (see RAND_DRBG_set_callbacks())
@@ -243,6 +353,33 @@ size_t rand_drbg_get_nonce(RAND_DRBG *drbg,
         int count;
     } data;
 
+#ifdef OPENSSL_FIPS
+    size_t entropy_available = 0;
+
+    if (FIPS_mode()) {
+        /* Use the SP800-90B compliant entropy source to acquire a nonce */
+        if (entropy < drbg->strength / 2) {
+            entropy = drbg->strength / 2;
+        }
+
+        pool = rand_pool_new(entropy, drbg->secure, min_len, max_len);
+        if (pool == NULL)
+            return 0;
+
+        entropy_available = rand_pool_acquire_entropy(pool);
+
+        if (entropy_available > 0) {
+            CRYPTO_atomic_add(&rand_nonce_count, 1, &data.count, rand_nonce_lock);
+            ret = rand_pool_length(pool);
+            *pout = rand_pool_detach(pool);
+        }
+
+        rand_pool_free(pool);
+
+        return ret;
+    }
+#endif
+
     memset(&data, 0, sizeof(data));
     pool = rand_pool_new(0, 0, min_len, max_len);
     if (pool == NULL)
diff --git a/crypto/rand/rand_local.h b/crypto/rand/rand_local.h
index 2d13e45..50c2e72 100644
--- a/crypto/rand/rand_local.h
+++ b/crypto/rand/rand_local.h
@@ -291,6 +291,12 @@ struct rand_drbg_st {
     RAND_DRBG_METHOD *meth;
 
     /* Callback functions.  See comments in rand_lib.c */
+#ifdef OPENSSL_FIPS
+    RAND_DRBG_get_pers_fn get_pers;
+    RAND_DRBG_get_adin_fn get_adin;
+    RAND_DRBG_cleanup_pers_fn cleanup_pers;
+    RAND_DRBG_cleanup_adin_fn cleanup_adin;
+#endif
     RAND_DRBG_get_entropy_fn get_entropy;
     RAND_DRBG_cleanup_entropy_fn cleanup_entropy;
     RAND_DRBG_get_nonce_fn get_nonce;
diff --git a/crypto/rand/rand_unix.c b/crypto/rand/rand_unix.c
index 4c2d54e..722d721 100644
--- a/crypto/rand/rand_unix.c
+++ b/crypto/rand/rand_unix.c
@@ -346,7 +346,7 @@ static ssize_t sysctl_random(char *buf, size_t buflen)
  * syscall_random(): Try to get random data using a system call
  * returns the number of bytes returned in buf, or < 0 on error.
  */
-static ssize_t syscall_random(void *buf, size_t buflen, int nonblock)
+ssize_t syscall_random(void *buf, size_t buflen, int nonblock)
 {
     /*
      * Note: 'buflen' equals the size of the buffer which is used by the
diff --git a/include/crypto/rand.h b/include/crypto/rand.h
index 479c16d..e6bc79c 100644
--- a/include/crypto/rand.h
+++ b/include/crypto/rand.h
@@ -33,6 +33,16 @@ size_t rand_acquire_entropy_from_tsc(RAND_POOL *pool);
 size_t rand_acquire_entropy_from_cpu(RAND_POOL *pool);
 
 /* DRBG entropy callbacks. */
+#ifdef OPENSSL_FIPS
+size_t rand_drbg_get_pers(RAND_DRBG *drbg,
+                          unsigned char **pout, size_t pers_len);
+void rand_drbg_cleanup_pers(RAND_DRBG *drbg,
+                            unsigned char *out, size_t outlen);
+size_t rand_drbg_get_adin(RAND_DRBG *drbg,
+                          unsigned char **pout, size_t adin_len);
+void rand_drbg_cleanup_adin(RAND_DRBG *drbg,
+                            unsigned char *out, size_t outlen);
+#endif
 size_t rand_drbg_get_entropy(RAND_DRBG *drbg,
                              unsigned char **pout,
                              int entropy, size_t min_len, size_t max_len,
@@ -145,4 +155,9 @@ void rand_pool_keep_random_devices_open(int keep);
  */
 int rand_drbg_selftest(void);
 
+/*
+ * Acquire random bits from Linux RNG
+ */
+ssize_t syscall_random(void *buf, size_t buflen, int nonblock);
+
 #endif
diff --git a/include/openssl/fips.h b/include/openssl/fips.h
index 701b37b..35c3c55 100644
--- a/include/openssl/fips.h
+++ b/include/openssl/fips.h
@@ -142,6 +142,7 @@ extern "C" {
 # define FIPS_F_RSA_OSSL_PRIVATE_ENCRYPT                  118
 # define FIPS_F_RSA_OSSL_PUBLIC_DECRYPT                   119
 # define FIPS_F_RSA_OSSL_PUBLIC_ENCRYPT                   120
+# define FIPS_F_FIPS_DRBG_LRNG                            200
 
 /* Reason codes. */
 # define FIPS_R_ADDITIONAL_INPUT_ERROR_UNDETECTED         150
@@ -190,6 +191,9 @@ extern "C" {
 # define FIPS_R_UNINSTANTIATE_ZEROISE_ERROR               138
 # define FIPS_R_UNSUPPORTED_DRBG_TYPE                     139
 # define FIPS_R_UNSUPPORTED_PLATFORM                      113
+# define FIPS_R_ERROR_RETRIEVING_PERS                     200
+# define FIPS_R_ERROR_RETRIEVING_ADIN                     201
+# define FIPS_R_ERROR_RETRIEVING_RAND                     202
 
 # ifdef  __cplusplus
 }
diff --git a/include/openssl/fips_rand.h b/include/openssl/fips_rand.h
index c924fd4..1330311 100644
--- a/include/openssl/fips_rand.h
+++ b/include/openssl/fips_rand.h
@@ -99,13 +99,38 @@ extern "C" {
                                                        unsigned char *out,
                                                        size_t olen));
 
+    int FIPS_drbg_set_all_callbacks(DRBG_CTX *dctx,
+                                size_t (*get_pers) (DRBG_CTX *ctx,
+                                                    unsigned char **pout,
+                                                    size_t pers_len),
+                                void (*cleanup_pers) (DRBG_CTX *ctx,
+                                                      unsigned char *out,
+                                                      size_t olen),
+                                size_t (*get_adin) (DRBG_CTX *ctx,
+                                                    unsigned char **pout,
+                                                    size_t adin_len),
+                                void (*cleanup_adin) (DRBG_CTX *ctx,
+                                                      unsigned char *out,
+                                                      size_t olen),
+                                size_t (*get_entropy) (DRBG_CTX *ctx,
+                                                       unsigned char **pout,
+                                                       int entropy,
+                                                       size_t min_len,
+                                                       size_t max_len),
+                                void (*cleanup_entropy) (DRBG_CTX *ctx,
+                                                         unsigned char *out,
+                                                         size_t olen),
+                                size_t entropy_blocklen,
+                                size_t (*get_nonce) (DRBG_CTX *ctx,
+                                                     unsigned char **pout,
+                                                     int entropy,
+                                                     size_t min_len,
+                                                     size_t max_len),
+                                void (*cleanup_nonce) (DRBG_CTX *ctx,
+                                                       unsigned char *out,
+                                                       size_t olen));
+
     int FIPS_drbg_set_rand_callbacks(DRBG_CTX *dctx,
-                                     size_t (*get_adin) (DRBG_CTX *ctx,
-                                                         unsigned char
-                                                         **pout),
-                                     void (*cleanup_adin) (DRBG_CTX *ctx,
-                                                           unsigned char *out,
-                                                           size_t olen),
                                      int (*rand_seed_cb) (DRBG_CTX *ctx,
                                                           const void *buf,
                                                           int num),
diff --git a/include/openssl/rand_drbg.h b/include/openssl/rand_drbg.h
index 45b731b..9bf650d 100644
--- a/include/openssl/rand_drbg.h
+++ b/include/openssl/rand_drbg.h
@@ -103,6 +103,7 @@ void *RAND_DRBG_get_ex_data(const RAND_DRBG *drbg, int idx);
 /*
  * Callback function typedefs
  */
+
 typedef size_t (*RAND_DRBG_get_entropy_fn)(RAND_DRBG *drbg,
                                            unsigned char **pout,
                                            int entropy, size_t min_len,
@@ -116,13 +117,33 @@ typedef size_t (*RAND_DRBG_get_nonce_fn)(RAND_DRBG *drbg, unsigned char **pout,
 typedef void (*RAND_DRBG_cleanup_nonce_fn)(RAND_DRBG *drbg,
                                            unsigned char *out, size_t outlen);
 
+#ifdef OPENSSL_FIPS
+typedef size_t (*RAND_DRBG_get_pers_fn)(RAND_DRBG *drbg,
+                                        unsigned char **pout, size_t pers_len);
+typedef void (*RAND_DRBG_cleanup_pers_fn)(RAND_DRBG *drbg,
+                                          unsigned char *out, size_t outlen);
+typedef size_t (*RAND_DRBG_get_adin_fn)(RAND_DRBG *drbg,
+                                        unsigned char **pout, size_t adin_len);
+typedef void (*RAND_DRBG_cleanup_adin_fn)(RAND_DRBG *drbg,
+                                          unsigned char *out, size_t outlen);
+int RAND_DRBG_set_fips_callbacks(RAND_DRBG *drbg,
+                                 RAND_DRBG_get_pers_fn get_pers,
+                                 RAND_DRBG_cleanup_pers_fn cleanup_pers,
+                                 RAND_DRBG_get_adin_fn get_adin,
+                                 RAND_DRBG_cleanup_adin_fn cleanup_adin,
+                                 RAND_DRBG_get_entropy_fn get_entropy,
+                                 RAND_DRBG_cleanup_entropy_fn cleanup_entropy,
+                                 RAND_DRBG_get_nonce_fn get_nonce,
+                                 RAND_DRBG_cleanup_nonce_fn cleanup_nonce);
+#endif
+
+
 int RAND_DRBG_set_callbacks(RAND_DRBG *drbg,
                             RAND_DRBG_get_entropy_fn get_entropy,
                             RAND_DRBG_cleanup_entropy_fn cleanup_entropy,
                             RAND_DRBG_get_nonce_fn get_nonce,
                             RAND_DRBG_cleanup_nonce_fn cleanup_nonce);
 
-
 # ifdef  __cplusplus
 }
 # endif
diff --git a/include/openssl/randerr.h b/include/openssl/randerr.h
index ba9fb91..ca80b54 100644
--- a/include/openssl/randerr.h
+++ b/include/openssl/randerr.h
@@ -29,6 +29,10 @@ int ERR_load_RAND_strings(void);
 # define RAND_F_RAND_BYTES                                100
 # define RAND_F_RAND_DRBG_ENABLE_LOCKING                  119
 # define RAND_F_RAND_DRBG_GENERATE                        107
+#ifdef OPENSSL_FIPS
+# define RAND_F_RAND_DRBG_GET_PERS                        128
+# define RAND_F_RAND_DRBG_GET_ADIN                        129
+#endif
 # define RAND_F_RAND_DRBG_GET_ENTROPY                     120
 # define RAND_F_RAND_DRBG_GET_NONCE                       123
 # define RAND_F_RAND_DRBG_INSTANTIATE                     108
@@ -38,6 +42,9 @@ int ERR_load_RAND_strings(void);
 # define RAND_F_RAND_DRBG_SET                             104
 # define RAND_F_RAND_DRBG_SET_DEFAULTS                    121
 # define RAND_F_RAND_DRBG_UNINSTANTIATE                   118
+#ifdef OPENSSL_FIPS
+# define RAND_F_RAND_DRBG_LRNG                            201
+#endif
 # define RAND_F_RAND_INIT_FIPS                            200
 # define RAND_F_RAND_LOAD_FILE                            111
 # define RAND_F_RAND_POOL_ACQUIRE_ENTROPY                 122
@@ -91,5 +98,10 @@ int ERR_load_RAND_strings(void);
 # define RAND_R_TOO_MUCH_NONCE_REQUESTED                  136
 # define RAND_R_UNSUPPORTED_DRBG_FLAGS                    132
 # define RAND_R_UNSUPPORTED_DRBG_TYPE                     120
+#ifdef OPENSSL_FIPS
+# define RAND_R_ERROR_RETRIEVING_PERS                     200
+# define RAND_R_ERROR_RETRIEVING_RAND                     201
+# define RAND_R_ERROR_NO_LRNG_CONCAT                      202
+#endif
 
 #endif
diff --git a/util/libcrypto.num b/util/libcrypto.num
index e354631..0b2d382 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -4635,4 +4635,7 @@ EVP_KDF_ctrl_str                        6595	1_1_1b	EXIST::FUNCTION:
 EVP_KDF_size                            6596	1_1_1b	EXIST::FUNCTION:
 EVP_KDF_derive                          6597	1_1_1b	EXIST::FUNCTION:
 EC_GROUP_check_named_curve              6598    1_1_1g	EXIST::FUNCTION:EC
-FIPS_init_entropy                       6599    1_1_1k  EXIST::FUNCTION:
\ No newline at end of file
+FIPS_init_entropy                       6599    1_1_1k  EXIST::FUNCTION:
+syscall_random                          6600    1_1_1k  EXIST::FUNCTION:
+RAND_DRBG_set_fips_callbacks            6601    1_1_1k  EXIST::FUNCTION:
+FIPS_drbg_set_all_callbacks             6602    1_1_1k  EXIST::FUNCTION:
\ No newline at end of file
diff --git a/util/private.num b/util/private.num
index e9420e7..ff8cc7a 100644
--- a/util/private.num
+++ b/util/private.num
@@ -46,8 +46,12 @@ PROFESSION_INFO                         datatype
 PROFESSION_INFOS                        datatype
 RAND_DRBG_cleanup_entropy_fn            datatype
 RAND_DRBG_cleanup_nonce_fn              datatype
+RAND_DRBG_cleanup_pers_fn               datatype
+RAND_DRBG_cleanup_adin_fn               datatype
 RAND_DRBG_get_entropy_fn                datatype
 RAND_DRBG_get_nonce_fn                  datatype
+RAND_DRBG_get_pers_fn                   datatype
+RAND_DRBG_get_adin_fn                   datatype
 RAND_poll_cb                            datatype
 SSL_CTX_allow_early_data_cb_fn          datatype
 SSL_CTX_keylog_cb_func                  datatype
