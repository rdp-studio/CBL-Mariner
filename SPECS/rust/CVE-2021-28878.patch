From a461afc27b43155dcf16430bc071682466011501 Mon Sep 17 00:00:00 2001
From: Thomas Crain <thcrain@microsoft.com>
Date: Mon, 26 Apr 2021 13:49:28 -0500
Subject: [PATCH 6/6] Fix CVE-2021-28878

Backported to 1.47.0:
https://github.com/rust-lang/rust/pull/82292
---
 library/core/src/iter/adapters/zip.rs | 13 +++++++++----
 library/core/tests/iter.rs            | 23 +++++++++++++++++++++++
 2 files changed, 32 insertions(+), 4 deletions(-)

diff --git a/library/core/src/iter/adapters/zip.rs b/library/core/src/iter/adapters/zip.rs
index e480bf2bc28..79f22583e5d 100644
--- a/library/core/src/iter/adapters/zip.rs
+++ b/library/core/src/iter/adapters/zip.rs
@@ -16,9 +16,10 @@ use super::super::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterat
 pub struct Zip<A, B> {
     a: A,
     b: B,
-    // index and len are only used by the specialized version of zip
+    // index, len and a_len are only used by the specialized version of zip
     index: usize,
     len: usize,
+    a_len: usize,
 }
 impl<A: Iterator, B: Iterator> Zip<A, B> {
     pub(in super::super) fn new(a: A, b: B) -> Zip<A, B> {
@@ -113,6 +114,7 @@ where
             b,
             index: 0, // unused
             len: 0,   // unused
+            a_len: 0, // unused
         }
     }
 
@@ -187,8 +189,9 @@ where
     B: TrustedRandomAccess + Iterator,
 {
     fn new(a: A, b: B) -> Self {
-        let len = cmp::min(a.size(), b.size());
-        Zip { a, b, index: 0, len }
+        let a_len = a.size();
+        let len = cmp::min(a_len, b.size());
+        Zip { a, b, index: 0, len, a_len }
     }
 
     #[inline]
@@ -200,7 +203,7 @@ where
             unsafe {
                 Some((self.a.__iterator_get_unchecked(i), self.b.__iterator_get_unchecked(i)))
             }
-        } else if A::may_have_side_effect() && self.index < self.a.size() {
+        } else if A::may_have_side_effect() && self.index < self.a_len {
             let i = self.index;
             self.index += 1;
             self.len += 1;
@@ -267,6 +270,7 @@ where
                     for _ in 0..sz_a - self.len {
                         self.a.next_back();
                     }
+                    self.a_len = self.len;
                 }
                 let sz_b = self.b.size();
                 if b_side_effect && sz_b > self.len {
@@ -278,6 +282,7 @@ where
         }
         if self.index < self.len {
             self.len -= 1;
+            self.a_len -= 1;
             let i = self.len;
             // SAFETY: `i` is smaller than the previous value of `self.len`,
             // which is also smaller than or equal to `self.a.len()` and `self.b.len()`
diff --git a/library/core/tests/iter.rs b/library/core/tests/iter.rs
index 913764894ec..bbadb5820e9 100644
--- a/library/core/tests/iter.rs
+++ b/library/core/tests/iter.rs
@@ -3260,3 +3260,26 @@ fn test_issue_82282() {
         panic!();
     }
 }
+
+#[test]
+fn test_issue_82291() {
+    use std::cell::Cell;
+
+    let mut v1 = [()];
+    let v2 = [()];
+
+    let called = Cell::new(0);
+
+    let mut zip = v1
+        .iter_mut()
+        .map(|r| {
+            called.set(called.get() + 1);
+            r
+        })
+        .zip(&v2);
+
+    zip.next_back();
+    assert_eq!(called.get(), 1);
+    zip.next();
+    assert_eq!(called.get(), 1);
+}
-- 
2.25.1
