Backported from upstream commits by Benjamin Beurdouche <bbeurdouche@mozilla.com>
https://hg.mozilla.org/projects/nss/rev/f282556e6cc7715f5754aeaadda6f902590e7e38
https://hg.mozilla.org/projects/nss/rev/c25adfdfab34ddb08d3262aac3242e3399de1095

Signed-off-by: Henry Beberman <henry.beberman@microsoft.com>
diff -Naur a/nss/gtests/pk11_gtest/pk11_chacha20poly1305_unittest.cc b/nss/gtests/pk11_gtest/pk11_chacha20poly1305_unittest.cc
--- a/nss/gtests/pk11_gtest/pk11_chacha20poly1305_unittest.cc	2019-05-10 14:14:18.000000000 -0700
+++ b/nss/gtests/pk11_gtest/pk11_chacha20poly1305_unittest.cc	2021-06-10 12:04:08.183647431 -0700
@@ -43,9 +43,26 @@
 
     SECItem params = {siBuffer, reinterpret_cast<unsigned char*>(&aead_params),
                       sizeof(aead_params)};
+    
+    // Encrypt with bad parameters (TagLen is too long)
+    unsigned int outputLen = 0;
+    aead_params.ulTagLen = 158072;
+    std::vector<uint8_t> output(data_len + aead_params.ulTagLen);
+    SECStatus rv = PK11_Encrypt(key.get(), kMech, &params, output.data(),
+                                &outputLen, output.size(), data, data_len);
+    EXPECT_EQ(SECFailure, rv);
+    EXPECT_EQ(0U, outputLen);
+
+    // Encrypt with bad parameters (TagLen is too short)
+    aead_params.ulTagLen = 2;
+    std::vector<uint8_t> output(data_len + aead_params.ulTagLen);
+    SECStatus rv = PK11_Encrypt(key.get(), kMech, &params, output.data(),
+                                &outputLen, output.size(), data, data_len);
+    EXPECT_EQ(SECFailure, rv);
+    EXPECT_EQ(0U, outputLen);
 
     // Encrypt.
-    unsigned int outputLen = 0;
+    aead_params.ulTagLen = 16;
     std::vector<uint8_t> output(data_len + aead_params.ulTagLen);
     SECStatus rv = PK11_Encrypt(key.get(), kMech, &params, output.data(),
                                 &outputLen, output.size(), data, data_len);
diff -Naur a/nss/gtests/pk11_gtest/pk11_cipherop_unittest.cc b/nss/gtests/pk11_gtest/pk11_cipherop_unittest.cc
--- a/nss/gtests/pk11_gtest/pk11_cipherop_unittest.cc	2019-05-10 14:14:18.000000000 -0700
+++ b/nss/gtests/pk11_gtest/pk11_cipherop_unittest.cc	2021-06-10 12:06:57.079302905 -0700
@@ -77,4 +77,53 @@
   NSS_ShutdownContext(globalctx);
 }
 
+TEST(Pkcs11CipherOp, SingleCtxMultipleUnalignedCipherOpsChaCha20) {
+  PK11SlotInfo* slot;
+  PK11SymKey* key;
+  PK11Context* ctx;
+
+  NSSInitContext* globalctx =
+      NSS_InitContext("", "", "", "", NULL,
+                      NSS_INIT_READONLY | NSS_INIT_NOCERTDB | NSS_INIT_NOMODDB |
+                          NSS_INIT_FORCEOPEN | NSS_INIT_NOROOTINIT);
+
+  const CK_MECHANISM_TYPE cipher = CKM_NSS_CHACHA20_CTR;
+
+  slot = PK11_GetInternalSlot();
+  ASSERT_TRUE(slot);
+
+  // Use arbitrary bytes for the ChaCha20 key and IV
+  uint8_t key_bytes[32];
+  for (size_t i = 0; i < 32; i++) {
+    key_bytes[i] = i;
+  }
+  SECItem keyItem = {siBuffer, key_bytes, 32};
+
+  uint8_t iv_bytes[16];
+  for (size_t i = 0; i < 16; i++) {
+    key_bytes[i] = i;
+  }
+  SECItem ivItem = {siBuffer, iv_bytes, 16};
+
+  SECItem* param = PK11_ParamFromIV(cipher, &ivItem);
+
+  key = PK11_ImportSymKey(slot, cipher, PK11_OriginUnwrap, CKA_ENCRYPT,
+                          &keyItem, NULL);
+  ctx = PK11_CreateContextBySymKey(cipher, CKA_ENCRYPT, key, param);
+  ASSERT_TRUE(key);
+  ASSERT_TRUE(ctx);
+
+  uint8_t outbuf[128];
+  // This is supposed to fail for Chacha20. This is because the underlying
+  // PK11_CipherOp operation is calling the C_EncryptUpdate function for
+  // which multi-part is disabled for ChaCha20 in counter mode.
+  ASSERT_EQ(GetBytes(ctx, outbuf, 7), SECFailure);
+
+  PK11_FreeSymKey(key);
+  PK11_FreeSlot(slot);
+  SECITEM_FreeItem(param, PR_TRUE);
+  PK11_DestroyContext(ctx, PR_TRUE);
+  NSS_ShutdownContext(globalctx);
+}
+
 }  // namespace nss_test
diff -Naur a/nss/lib/freebl/chacha20poly1305.c b/nss/lib/freebl/chacha20poly1305.c
--- a/nss/lib/freebl/chacha20poly1305.c	2019-05-10 14:14:18.000000000 -0700
+++ b/nss/lib/freebl/chacha20poly1305.c	2021-06-10 11:54:41.192530256 -0700
@@ -111,7 +111,7 @@
         PORT_SetError(SEC_ERROR_BAD_KEY);
         return SECFailure;
     }
-    if (tagLen == 0 || tagLen > 16) {
+    if (tagLen != 16) {
         PORT_SetError(SEC_ERROR_INPUT_LEN);
         return SECFailure;
     }
diff -Naur a/nss/lib/softoken/pkcs11c.c b/nss/lib/softoken/pkcs11c.c
--- a/nss/lib/softoken/pkcs11c.c	2019-05-10 14:14:18.000000000 -0700
+++ b/nss/lib/softoken/pkcs11c.c	2021-06-10 11:41:44.429521228 -0700
@@ -1207,6 +1207,7 @@
             break;
 
         case CKM_NSS_CHACHA20_CTR:
+            context->multi = PR_FALSE;
             if (key_type != CKK_NSS_CHACHA20) {
                 crv = CKR_KEY_TYPE_INCONSISTENT;
                 break;
